<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title></title>
</head>
<body>
<!-- 
Vue2.x与1.x最大的区别是 使用了Virtual Dom 来更新DOM节点，替身渲染性能。
Virtual Dom并不是真正意义上的DOM，而是轻量级的JavaScript对象。
	在状态发生变化时，Virtual Dom会进行Diff运算，来更新只需要被替换的DOM，而不是全部重绘。
与DOM操作相比，Virtual Dom是基于JavaScript计算的，所以开销会小很多。

Object
	->render生成虚拟节点
	->createElement(h)基于续集节点创建dom节点
	->diff状态更新后，进行对比，生成补丁对象
	->patch遍历补丁对象，更新dom节点
 -->
<!-- 
Virtual Dom就是通过一种VNode类表达的，
每个DOM元素或组件都对应个VNode对象。
VNode主要分为如下几类
	EmptyVNode:没有内容的注释节点
	ComponentVNode:组件节点
	TextNode:文本节点
	ElementVNode:普通元素节点
	CloneVNode:克隆节点，可以是以上任意类型的节点，唯一区别在于isCloned=true

使用虚拟节点完全发挥JavaScript的编程能力。
在多数场景中，使用template足够，但在一些特定的场景下，使用虚拟节点简单

export interface VNode {
	tag?:string;//当前节点的标签名
	data?:VNodeData;//当前节点的数据对象
	children?:VNode[];//子节点，数组，也是VNode类型
	text?:string;//当前节点的文本，一般文本节点或注释节点会有该属性
	elm?:Node;//当前虚拟对应的真实的DOM节点
	ns?|:string;//节点的namespace
	context?:Vue;//编译作用域
	key?:string|number;//节点的key属性，用于作为节点的标识，有利于patch的优化
	componentOptions?:VNodeComponentOptions;//创建组件实例时会用到的选项信息
	componentInstance?:Vue;
	parent?:VNode;//组件的占位节点
	raw?:booleam;//元素html
	isStatic?:boolean;//静态节点的标识
	isRootInsert:boolean;//是否作为根节点插入，被<transition>包裹的节点，该属性的值为false
	isComent:boolean;//当前节点是否为注释节点
}
 
VNodeData代码如下
export interface VNodeData{}
 -->
<div id="app">
	
</div>

<script src="https://cdn.bootcss.com/vue/2.6.10/vue.js"></script>
<script>
	Vue.component('',{
		template
	});
	var app = new Vue({
		el:'#app'
	});
</script>
</body>
</html>
